apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: assetuuidrequired
  annotations:
    description: "Requires deployments to have an assetUuid label with exclusion support"
spec:
  crd:
    spec:
      names:
        kind: AssetUuidRequired
      validation:
        openAPIV3Schema:
          type: object
          properties:
            enforcementMode:
              type: string
              enum: ["loose", "strict"]
              description: "Enforcement mode: loose (new only) or strict (all)"
            excludeExisting:
              type: boolean
              description: "Whether to exclude existing deployments"
            exemptNamespaces:
              type: array
              items:
                type: string
              description: "Namespaces to exempt from this policy"
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package assetuuidrequired

        violation[{"msg": msg}] {
          # Only apply to Deployment resources
          input.review.kind.kind == "Deployment"
          
          # Check if namespace is exempt
          not is_exempt_namespace
          
          # Check if resource is excluded by annotation
          not is_excluded_by_annotation
          
          # Check if resource is excluded by time-based annotation
          not is_excluded_by_time
          
          # Check enforcement mode
          should_enforce
          
          # Check if assetUuid label is missing
          not has_asset_uuid
          
          msg := sprintf("Deployment '%s' in namespace '%s' must have an 'assetUuid' label", [
            input.review.object.metadata.name,
            input.review.object.metadata.namespace
          ])
        }

        # Check if namespace is exempt
        is_exempt_namespace {
          input.parameters.exemptNamespaces[_] == input.review.object.metadata.namespace
        }

        # Check if resource is excluded by annotation
        is_excluded_by_annotation {
          input.review.object.metadata.annotations["opa.example.com/exclude"] == "true"
        }

        # Check if resource is excluded by time-based annotation
        is_excluded_by_time {
          exclude_until := input.review.object.metadata.annotations["opa.example.com/exclude-until"]
          exclude_until != ""
          time.parse_rfc3339_ns(exclude_until) > time.now_ns()
        }

        # Determine if we should enforce based on mode
        should_enforce {
          input.parameters.enforcementMode == "strict"
        }

        should_enforce {
          input.parameters.enforcementMode == "loose"
          # In loose mode, only enforce on new deployments
          # We consider a deployment "new" if it doesn't have the exclude annotation
          not input.review.object.metadata.annotations["opa.example.com/existing"]
        }

        # Check if assetUuid label exists and is not empty
        has_asset_uuid {
          asset_uuid := input.review.object.metadata.labels.assetUuid
          asset_uuid != ""
          count(asset_uuid) > 0
        }
