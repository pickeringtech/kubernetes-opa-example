apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: assetuuidrequiredstrict
  annotations:
    description: "ACME Payments Inc. FinOps Compliance - Asset UUID Requirement for Cost Optimization"
    organization: "ACME Payments Inc."
    policy-category: "finops-compliance"
    cost-impact: "high"
spec:
  crd:
    spec:
      names:
        kind: AssetUuidRequiredStrict
      validation:
        openAPIV3Schema:
          type: object
          properties:
            enforcementMode:
              type: string
              enum: ["loose", "strict"]
              description: "Enforcement mode: loose (new only) or strict (all)"
            excludeExisting:
              type: boolean
              description: "Whether to exclude existing deployments"
            exemptNamespaces:
              type: array
              items:
                type: string
              description: "Namespaces to exempt from this policy"
            exemptionS3Config:
              type: object
              properties:
                endpoint:
                  type: string
                  description: "S3 endpoint URL for exemption data"
                bucket:
                  type: string
                  description: "S3 bucket containing exemption data"
                key:
                  type: string
                  description: "S3 key path to exemption JSON file"
              description: "S3 configuration for centralized exemption management"
            exemptionConfigMap:
              type: object
              properties:
                name:
                  type: string
                  description: "Name of the ConfigMap containing exemption data"
                namespace:
                  type: string
                  description: "Namespace of the ConfigMap containing exemption data"
              description: "ConfigMap reference for centralized exemption management"
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package assetuuidrequired

        violation[{"msg": msg}] {
          # Only apply to Deployment resources
          input.review.kind.kind == "Deployment"

          # Check if namespace is exempt
          not is_exempt_namespace

          # Check if resource is centrally exempted
          not is_centrally_exempted

          # Check enforcement mode
          should_enforce

          # Check if assetUuid label is missing
          not has_asset_uuid

          msg := sprintf("ðŸ¦ ACME Payments Inc. FinOps Policy Violation - STRICT ENFORCEMENT\n\nðŸ“‹ VIOLATION DETAILS:\nDeployment: %s\nNamespace: %s\n\nâŒ CRITICAL COMPLIANCE ISSUE:\nMissing required 'assetUuid' label for cost tracking and optimization.\n\nðŸš¨ DEPLOYMENT BLOCKED:\nThis deployment has been DENIED due to strict FinOps compliance requirements.\n\nðŸ“Š BUSINESS IMPACT:\nâ€¢ Cost center allocation impossible\nâ€¢ Resource optimization tracking disabled\nâ€¢ Non-compliance with ACME Payments financial governance\nâ€¢ Potential audit findings and regulatory issues\n\nðŸ”§ IMMEDIATE ACTION REQUIRED:\nAdd an 'assetUuid' label with a valid asset identifier to enable:\nâ€¢ Cost center allocation and chargeback\nâ€¢ Resource optimization tracking\nâ€¢ Compliance with payment industry standards\nâ€¢ Audit trail for financial reporting\n\nðŸ“ž URGENT SUPPORT:\nContact: finops-team@acmepayments.com\nEscalation: finops-director@acmepayments.com\nDocumentation: https://wiki.acmepayments.com/finops/asset-tagging\nEmergency Ticket: https://jira.acmepayments.com/finops/emergency", [
            input.review.object.metadata.name,
            input.review.object.metadata.namespace
          ])
        }

        # Check if namespace is exempt
        is_exempt_namespace {
          input.parameters.exemptNamespaces[_] == input.review.object.metadata.namespace
        }

        # Check if resource is centrally exempted via S3
        is_centrally_exempted {
          # Fetch exemption data from S3
          s3_url := sprintf("%s/%s/%s", [input.parameters.exemptionS3Config.endpoint, input.parameters.exemptionS3Config.bucket, input.parameters.exemptionS3Config.key])
          response := http.send({
            "method": "GET",
            "url": s3_url,
            "headers": {"Accept": "application/json"}
          })
          response.status_code == 200
          exemption_data := json.unmarshal(response.body)

          # Check for permanent exemptions
          deployment_key := sprintf("%s/%s", [input.review.object.metadata.namespace, input.review.object.metadata.name])
          exemption_data.permanent_exemptions[deployment_key]
        }

        is_centrally_exempted {
          # Fetch exemption data from S3 for time-based exemptions
          s3_url := sprintf("%s/%s/%s", [input.parameters.exemptionS3Config.endpoint, input.parameters.exemptionS3Config.bucket, input.parameters.exemptionS3Config.key])
          response := http.send({
            "method": "GET",
            "url": s3_url,
            "headers": {"Accept": "application/json"}
          })
          response.status_code == 200
          exemption_data := json.unmarshal(response.body)

          # Check for time-based exemptions
          deployment_key := sprintf("%s/%s", [input.review.object.metadata.namespace, input.review.object.metadata.name])
          time_exemption := exemption_data.time_based_exemptions[deployment_key]
          time_exemption.expires_at != ""
          time.parse_rfc3339_ns(time_exemption.expires_at) > time.now_ns()
        }

        # Determine if we should enforce based on mode
        should_enforce {
          input.parameters.enforcementMode == "strict"
        }

        should_enforce {
          input.parameters.enforcementMode == "loose"
          # In loose mode, only enforce on new deployments
          # We consider a deployment "new" if it doesn't have the exclude annotation
          not input.review.object.metadata.annotations["opa.example.com/existing"]
        }

        # Check if assetUuid label exists and is not empty
        has_asset_uuid {
          asset_uuid := input.review.object.metadata.labels.assetUuid
          asset_uuid != ""
          count(asset_uuid) > 0
        }
